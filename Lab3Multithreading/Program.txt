//#define COLSROWS 2


kernel void myGEMM3(const global float* A, const global float* B, global float* C,
                            const int M, const int N, const int K) {
    

    const int row = get_local_id(0); // Local row ID (max: TS)
    const int col = get_local_id(1); // Local col ID (max: TS)


    const int globalRow = TS*get_group_id(0) + row; // Row ID of C (0..M)  или то же самое что и get_global_id(0)
    const int globalCol = TS*get_group_id(1) + col; // Col ID of C (0..N) или то же самое что и get_global_id(1)

    local float Asub[TS][TS];
    local float Bsub[TS][TS];

    float acc[WPT];
    for (int w=0; w<WPT; w++) {
        acc[w] = 0.0f;
    }
 

    // Loop over all tiles
    const int numTiles = K/TS;
    for (int t=0; t<numTiles; t++) 
    {
 
        //в данным цикле каждый треж копирует для себя строчку из 8 элементов для умножения
        // Load one tile of A and B into local memory
           for (int w=0; w<WPT; w++) {
            const int tiledRow = TS*t + row;
            const int tiledCol = TS*t + col;
            Asub[col + w*RTS][row] = A[(tiledCol + w*RTS)*M + globalRow];
            Bsub[col + w*RTS][row] = B[(globalCol + w*RTS)*K + tiledRow];
            //printf("\nAsub[%d + %d*%d][%d] = %f, Bsub[%d + %d*%d][%d] = %f",
            //col, w, RTS, row, A[(tiledCol + w*RTS)*M + globalRow], col, w, RTS, row, B[(globalCol + w*RTS)*K + tiledRow]);
        }

        // Synchronise to make sure the tile is loaded
        barrier(CLK_LOCAL_MEM_FENCE);
 
        // Perform the computation for a single tile
         for (int k=0; k<TS; k++) {//перемещение по строке из 8ми элементов и вычисление каждого элемента
            for (int w=0; w<WPT; w++) {
                acc[w] += Asub[k][row] * Bsub[col + w*RTS][k];//умножение строки на столбец
            }
        }
        
        // Synchronise before loading the next tile, синхронизируем перед загрузкой следующей пары подматриц для получения окончательного результата(для матр 4 на 4)
        barrier(CLK_LOCAL_MEM_FENCE);
    }

     // Store the final result in C
    for (int w=0; w<WPT; w++) {
        C[(globalCol + w*RTS)*M + globalRow] = acc[w];
    }
}






kernel void matrix_multiplication(global const float* a, global const float* b, global float* c, int wA, int wB)
{
	int tx = get_global_id(0); 
	int ty = get_global_id(1);

   float value = 0.0;
   for (int k = 0; k < wA; ++k)
   {
      value += a[ty * wA + k] * b[k * wB + tx];
   }

   c[ty * wB + tx] = value;
}

//как только кернел выполнится всей локальной группой(она закончится), то его начнет выполнять следующая лок группа
kernel void matricesMul(global const float* in1, global const float* in2, global float* out, int COLSROWSs, int COLS2)
{

         int r = get_global_id( 0 );//не дает пересекаться локальным группам,у нас всегда есть общаа работа( global work size)
         //и этот индекс уникальный для каждого треда, который может быть частью локальной группы



         //for(int i=0; i<COLSROWS; i++){
             //rowbuf[i] = in1[ r * COLSROWS + i ]; 
             //printf("\nrowbuf[%d] = %f, r = %d, Collsrows = %d", i, rowbuf[i], r, COLSROWS);
         //}


         float rowbuf[ COLSROWS ]; 
         for( int col = 0; col < COLSROWS; col ++ )
            rowbuf[ col ] = in1[ r * COLSROWS + col ];

         int idlocal = get_local_id( 0 );//в данном случае нужен чтобы перенести 1 элемент
         int nlocal = get_local_size( 0 );//также нужен чтобы перенести 1 элемент и не позволить носить дальше в for'е

         //printf("\nidlocal = %d", idlocal);
         //printf("\nnlocal = %d", nlocal);

         local float colbuf[COLSROWS]; 


         float sum;
         for( int c = 0; c < COLS2; c ++ )//вычисление всей строки матрицы
         {
            for( int cr = idlocal; cr < COLSROWS; cr = cr + nlocal )
            {
                colbuf[cr] = in2[ cr + c * COLSROWS ]; 
                //printf("\ncolbuf[%d] = %f, idLocal = %d", cr, colbuf[cr],  idlocal);
            }
                

                barrier( CLK_LOCAL_MEM_FENCE ); //барьер ожидает пока все потоки не перенесут по1 элементу в общий массив colbuf 

                //тут каждый поток считает элементы для своей строки используя общий локальный массив(столбец
                //матрицы) одновременно

            sum = 0.0;
            for( int cr = 0; cr < COLSROWS; cr ++ )//вычисление элемента матрицы
                sum += rowbuf[ cr ] * colbuf[cr];//rowbuf - у каждого потока своя строка которую он умножает на общий столбец
                out[ r * COLS2 + c ] = sum;
         } 
}



kernel void matricesMulVector(global const float* in1, global const float* in2, global float* out, int COLSROWSs, int COLS2)
{

         int r = get_global_id( 0 );


         float rowbuf[ COLSROWS ]; 
         for( int col = 0; col < COLSROWS; col ++ )
            rowbuf[ col ] = in1[ r * COLSROWS + col ];


         float sum;
         for( int c = 0; c < COLS2; c ++ )//вычисление всей строки матрицы
         {
            sum = 0.0;
            for( int cr = 0; cr < COLSROWS; cr += 4 )//вычисление элемента матрицы
                sum += dot(( float4 ) ( rowbuf[ cr ],
                                        rowbuf[ cr + 1 ],
                                        rowbuf[ cr + 2 ],
                                        rowbuf[ cr + 3 ] ),
                        ( float4 ) ( in2[c * COLSROWS + cr],
                                     in2[c * COLSROWS + cr + 1 ],
                                     in2[c * COLSROWS + cr + 2 ],
                                     in2[c * COLSROWS + cr + 3 ] ));

                out[ r * COLS2 + c ] = sum;
         } 
}

